package service

import (
	"bytes"
	"context"
	"fmt"
	"html/template"
	"os"
	"sync"

	"github.com/coreos/go-systemd/v22/dbus"
)

type Systemd struct {
	once sync.Once
}

func (s Systemd) conn(ctx context.Context) *dbus.Conn {
	systemd, err := dbus.NewSystemdConnectionContext(ctx)
	if err != nil {
		panic("unable to get dbus system connection to systemd")
	}
	return systemd
}

func (s Systemd) CreateService() error {
	serviceTemplate := `# generated by egpu-switcher
[Unit]
Description=EGPU Service
Before=display-manager.service
After=bolt.service

[Service]
Type=oneshot
ExecStart=/usr/bin/egpu-switcher switch auto

[Install]
WantedBy=graphical.target
`

	buf := bytes.NewBuffer(nil)
	t := template.Must(template.New("service").Parse(serviceTemplate))
	err := t.Execute(buf, nil)
	if err != nil {
		return err
	}
	path := "/etc/systemd/system/egpu.service"
	err = os.WriteFile(path, buf.Bytes(), 0644)
	if err != nil {
		return fmt.Errorf("unable to generate systemd service file: %s", err)
	}
	ctx := context.Background()
	systemd := s.conn(ctx)
	err = systemd.ReloadContext(ctx)
	if err != nil {
		return fmt.Errorf("unable to run systemd daemon-reload: %s", err)
	}
	_, _, err = systemd.EnableUnitFilesContext(ctx, []string{path}, false, false)
	if err != nil {
		return fmt.Errorf("unable to enable egpu.serivce: %s", err)
	}
	return nil
}

func (s Systemd) TeardownService() error {
	// todo: systemctl show -p LoadState egpu.service | sed 's/LoadState=//g') == "loaded" (only attempt stop if service is loaded)
	// todo: systemctl stop egpu.service
	// todo: systemctl disable egpu.service
	// todo: delete service file
	// todo: systemctl daemon-reload
	// todo: reset-failed
	return fmt.Errorf("not implemented")
}

func createService() {
	// todo
}

func daemonReload() {
	// todo
}

func enable() {
	// todo
}
